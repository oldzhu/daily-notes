still see the error after /exec run

copilot> /exec file /workspace/examples/crash/python/crash.py
(pydb) file /workspace/examples/crash/python/crash.py
[pdb] script set to /workspace/examples/crash/python/crash.py
copilot> /exec run
(pydb) run

/workspace/examples/crash/python/crash.py(1)<module>()
-> def boom() -> None:
[pdb] timeout waiting for 'run'
copilot>
before u try to fix, please refer the project https://github.com/plasma-umass/ChatDBG which also support pdb(python debugger) so u can compare the difference betwen our implementation to support pdb backend and their implementation for pdb support, it could be helpful for us as it already works.
==========
Updated python_pdb.py so prompt detection tolerates ANSI/braided paste sequences, stops trying to rewrite the pdb prompt, and normalizes captured output instead of surfacing raw pexpect EOF/timeouts. Result: /exec run now echoes the useful stack lines and, when a script path is wrong, returns pdb’s own “Error: … does not exist” message instead of the previous traceback dump.
Compared with ChatDBG’s approach: they patch pdb in-process via IPython/ipdb (see \plasma-umass\chatdbg\tree\main\src\chatdbg\chatdbg_pdb.py), so they never parse subprocess prompts. Our backend continues to drive python -m pdb through pexpect, so resilient prompt matching and friendly failure handling are the critical differences.
Tests: /workspace/.venv/bin/python -m pytest -q

Next step: re-run /exec run and a follow-up command (e.g. /exec where) in the REPL to confirm the improved prompt handling in your workflow.
