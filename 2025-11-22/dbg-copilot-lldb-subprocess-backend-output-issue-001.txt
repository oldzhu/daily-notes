when I try to use pexpect to launch lldb process and try to run command in lldb and get the output of the command, that works for gdb but we can not capture output for lldb(always get empty output for executed lldb command), is this known issue or any solution?
========
Yes, this is a known issue related to how pexpect interacts with the buffering behavior of certain child processes, including lldb, compared to gdb. The issue often stems from output buffers not being flushed unless they are full or the program exits. 
Here are the solutions and workarounds to capture output from lldb using pexpect:
Solutions and Workarounds
1. Explicitly Wait for the lldb Prompt
The most robust approach is to explicitly wait for the (lldb) prompt after sending a command before attempting to read the output. This ensures pexpect captures the output generated by the command.
python
import pexpect
import sys

# Launch lldb with the target program (replace 'my_program' with your executable path)
child = pexpect.spawn('lldb my_program')
child.logfile_read = sys.stdout.buffer # Optional: useful for debugging

# Wait for the initial lldb prompt
child.expect('\(lldb\)')

# Send a command (e.g., 'run')
child.sendline('run')

# Wait for the (lldb) prompt to reappear after the 'run' command
child.expect('\(lldb\)') 

# The output of the 'run' command will now be in child.before
output_after_run = child.before.decode('utf-8')
print("Output of 'run' command:\n", output_after_run)

# Send another command (e.g., 'bt' for backtrace)
child.sendline('bt')
child.expect('\(lldb\)') 
output_after_bt = child.before.decode('utf-8')
print("Output of 'bt' command:\n", output_after_bt)

# Exit lldb
child.sendline('exit')
child.expect(pexpect.EOF)
Key takeaway: Always follow child.sendline() with a child.expect('\(lldb\)') to synchronize with the debugger's prompt. The captured output will be in the child.before attribute. 
2. Force Line Buffering using a Shell Wrapper (Workaround) 
A common workaround for programs that have unusual buffering behavior is to wrap the command in a shell using bash -c. This often forces line buffering on the output, making it easier for pexpect to capture it.
python
# Wrap lldb in a bash shell
command = 'bash -c "lldb my_program"'
child = pexpect.spawn(command)

# Proceed with expecting the prompt as in Solution 1
child.expect('\(lldb\)') 
# ...
Use code with caution.

This is less ideal but can fix situations where direct spawning fails. 
3. Adjust the delaybeforesend Attribute 
pexpect automatically adds a small delay before sending data to mimic human interaction. In rare cases, adjusting or removing this delay might help, but the first solution is generally more effective for prompt-based applications. 
python
child = pexpect.spawn('lldb my_program')
child.delaybeforesend = 0.1 # Tune the delay in seconds if necessary
Use code with caution.

Why it works for GDB but not LLDB
gdb and lldb are built with different foundational libraries and philosophies. Their internal handling of standard input/output streams and TTY behavior differs, which is why pexpect, which relies on pseudo-TTYs (pty module), works seamlessly with one but requires explicit prompt expectation for the other.
