the source works now, but I am think another probem is that how about our release, I mean we finally will porived the release files to our end user to donwload and work, it is hard to ask them to have he same folders layout as our devlopment environment, now we can add src path to solve he module error, but what will be final folders/files in our release, we'd bettter to decide the released layout and files and all tests hould be on the release

========
Good question — packaging and release layout matter a lot for users. Below I’ll cover recommended release artifacts, the ideal installed layout, how users will run the plugin without replicating your dev tree, CI/test guidance, and an actionable plan I can implement for you.

Goals (what we want for users)
Users can install the project with a single command (pip install wheel/sdist).
After install, the GDB plugin file(s) are importable and easy to source inside GDB (no manual path fiddling).
Releases include a wheel (fast install) and sdist (source).
CI runs tests and builds artifacts before publishing.
Secrets/keys not stored in package; provider credentials remain env/keyring-based.
Recommended release artifacts
Wheel (.whl) — primary artifact for users (pip install).
Source distribution (.tar.gz) — for reproducibility.
Optionally: packaged Docker image or distro packages (deb/rpm) if you want to support system-wide installs.
Build tools: use the existing pyproject.toml with setuptools (you already have it). Use:

python -m build
pip install dist/dbgcopilot-<ver>-py3-none-any.whl
Installed layout (what pip-installed users will see)
Package installed to site-packages as:

site-packages/dbgcopilot/
__init__.py
core/
backends/
plugins/
gdb/
copilot_cmd.py
repl.py
llm/
prompts/
utils/
This is ideal: the plugin becomes importable as dbgcopilot.plugins.gdb.copilot_cmd and the copilot plugin file is physically at:
Python: os.path.join(os.path.dirname(dbgcopilot.file), "plugins", "gdb", "copilot_cmd.py")
So the user can source it from GDB with one line:
(gdb) source $(python -c "import dbgcopilot, os; print(os.path.join(os.path.dirname(dbgcopilot.file), 'plugins','gdb','copilot_cmd.py'))")

To make this extra-easy we can also provide a tiny console script entry point (installed as a small CLI):

dbgcopilot-plugin-path
Prints the absolute path to copilot_cmd.py so users can run:
(gdb) source $(dbgcopilot-plugin-path)
What to include in the released package
The dbgcopilot package (all Python modules).
gdb as package files (they should be within the package tree under gdb so pip installs them).
default.yaml, prompts/, examples — optionally include examples and README as package data or keep examples in repository (not required).
Do not include tests in the installed package (they stay in repo/CI). You can include them in sdist if desired.
CI / tests policy for release
CI should run unit tests, linters, and build the sdist/wheel on pushes/tags.
Only publish artifacts (to PyPI or private index) from CI after tests pass.
Tests remain in repo (not normally shipped to users). We can package them into sdist for transparency, but it's optional.
Versioning & publishing
Use semantic versioning (v0.1.0) for POC, bump on breaking changes.
Release steps:
Run tests in CI.
Build artifacts: python -m build
Upload to PyPI/test.pypi with twine (or to internal index).
For private distribution, publish a wheel file and provide install command:
pip install dbgcopilot-0.1.0-py3-none-any.whl
Minimal changes I can implement now (recommended POC)
I can implement a small, low-risk set of changes so end users can install via pip and use the plugin immediately:

Fix pyproject.toml formatting and declare runtime dependencies:

Add requests to dependencies.
Optionally add keyring as optional dependency, e.g. openrouter[secure].
Add a tiny console entry point (in src/dbgcopilot/cli.py) that prints the plugin path:

console_scripts entry: dbgcopilot-plugin-path = dbgcopilot.cli:print_plugin_path
Ensure the gdb code lives inside the package (it already does under src) so pip will include it.

Add short README snippet explaining:

pip install the package
how to source plugin in GDB (two options: using python -c or dbgcopilot-plugin-path).
Add a Makefile target or GitHub Actions workflow to:

run tests, build wheel, and produce artifacts (optional next step).
This is a minimal set that makes releases usable and doesn't change runtime behavior.

Example commands for users (after we publish a wheel)
Install:
pip install dbgcopilot==0.1.0
Start GDB and source the plugin:
(gdb) source $(python -c "import dbgcopilot, os; print(os.path.join(os.path.dirname(dbgcopilot.file), 'plugins','gdb','copilot_cmd.py'))")
or if we add the CLI:
(gdb) source $(dbgcopilot-plugin-path)
Security note about packaging
Don’t ship secrets in the wheel. Keep API key handling via environment variables or OS keyring.
Document configuration (env vars) clearly in README.
Proposed next-step (pick one)
A: I implement the minimal packaging changes now: update pyproject.toml properly, add the console script dbgcopilot-plugin-path and a small src/dbgcopilot/cli.py, and update README. I’ll run tests and show you how to build a wheel and test pip install --no-index --find-links=dist ....
B: I add CI workflow that runs tests and builds wheel on tag (longer).
C: I only update pyproject.toml to properly declare dependencies and leave entry point for later.
Which should I do? If you pick A I’ll:

Create src/dbgcopilot/cli.py with print_plugin_path() function.
Update pyproject.toml dependencies and add project.scripts entry.
Run tests and show build/install commands to try locally.
