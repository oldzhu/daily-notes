u mention we should not save or commit pi key, if Add /llm add openrouter api_key=<key> model=<model> to persist provider-specific settings into the session, is it safe?
==========

Short answer: don’t persist raw API keys into source or unencrypted files. For a POC it's okay to keep a key in-memory (e.g., SESSION.config) while a session runs, but that still exposes the secret to process memory and it’s lost on restart. For anything more durable or convenient, prefer environment variables or a secure OS keyring. Below I list safe options and a recommended implementation you can use now.

Options (pros / cons)
Environment variable (recommended for simple dev)

Pros: simple, won’t end up in source control, works well in containers.
Cons: visible to any process that can read environment; you must set it each session or provide via container/CI secrets.
Example: export OPENROUTER_API_KEY="sk-..."
OS keyring (recommended for interactive dev on your machine)

Pros: stores secrets in the platform credential store (Windows Credential Manager / macOS Keychain / Secret Service on Linux). Safer than plain files.
Cons: requires the keyring Python package; behavior varies by OS; headless servers may need additional configuration.
Usage pattern: store once with keyring.set_password('dbgcopilot', 'openrouter', API_KEY) and read with keyring.get_password('dbgcopilot', 'openrouter').
I can implement /llm config set openrouter api_key=<key> to save into keyring.
Encrypted config file (acceptable if you implement encryption correctly)

Pros: portable encrypted storage.
Cons: you need to manage a master password or key; adds complexity. Use cryptography.Fernet or similar.
Not recommended for quick POC unless you want offline persistence and are comfortable with encryption keys.
Plain config file (NOT recommended)

Writing the API key to a YAML/JSON file is convenient but dangerous unless you encrypt it and ensure very restrictive permissions (chmod 600). Never commit to git.
In-memory only (SESSION.config)

Pros: simplest for POC, easy to implement.
Cons: lost on restart, present in process memory (dumpable), may leak into logs if you accidentally print SESSION.config.
Best practices
Never commit secrets to git — check .gitignore and scan the repo.
Use separate keys (dev/test) with limited scope for POC.
Rotate keys regularly and revoke unused keys.
Mask secrets in logs and in any /config show command.
Prefer least privilege and short-lived tokens where supported.
Concrete recommendation for dbgcopilot (what I suggest we implement now)
Fallback order for resolving the OpenRouter key:
OS keyring
environment variable OPENROUTER_API_KEY
SESSION.config['openrouter_api_key'] (in-memory only)
Implement REPL subcommands:
/llm config set openrouter api_key=<key> model=<model> — stores the API key in OS keyring and model into SESSION.config.
/llm config show — lists provider config but masks secrets (e.g., show openrouter_api_key = *****).
/llm config unset openrouter — removes the key from keyring and clears session config.
Never print secrets in the REPL or reports. Mask them.
I can implement the keyring-backed approach now (quick plan):

Add pip dependency note (keyring), but keep the code tolerant if keyring is not installed (fall back to env / session).
Add helper in openrouter.py or a small utility in providers.py to resolve API key from keyring/env/session.
Add REPL handlers (/llm config set, /llm config show, /llm config unset) in repl.py.
Add small unit tests that mock keyring (and ensure we mask secrets on show).
Do you want me to implement the keyring-backed /llm config set and show/unset commands now? If yes, confirm and I’ll proceed and commit the changes.


