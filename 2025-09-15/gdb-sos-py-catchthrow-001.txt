Hold on on all fixes before we identified the root cause. You said C++ throw can work to resolve new Jitted functions. Then why lldb below c++ breakpoint call back works?

HRESULT HandleRuntimeLoadedNotification(ILLDBServices *client)
{
    INIT_API_EFN();
    EnableModuleLoadUnloadCallbacks();
    return g_ExtServices->SetExceptionCallback(HandleExceptionNotification);
}
...
HRESULT HandleExceptionNotification(ILLDBServices *client)
{
    INIT_API_EFN();
    return HandleCLRNotificationEvent();
}
...
HRESULT HandleCLRNotificationEvent()
{
    /*
     * Did we get module load notification? If so, check if any in our pending list
     * need to be registered for jit notification.
     *
     * Did we get a jit notification? If so, check if any can be removed and
     * real breakpoints be set.
     */
    DEBUG_LAST_EVENT_INFO_EXCEPTION dle;
    CNotification Notification;

    if (!CheckCLRNotificationEvent(&dle))
    {
#ifndef FEATURE_PAL
        ExtOut("Expecting first chance CLRN exception\n");
        return E_FAIL;
#else
        g_ExtControl->Execute(DEBUG_OUTCTL_NOT_LOGGED, "process continue", 0);
        return S_OK;
#endif
    }

    // Notification only needs to live for the lifetime of the call below, so it's a non-static
    // local.
    HRESULT Status = g_clrData->TranslateExceptionRecordToNotification(&dle.ExceptionRecord, &Notification);
    if (Status != S_OK)
    {
        ExtErr("Error processing exception notification\n");
        return Status;
    }
    else
    {
        switch (Notification.GetDebugStatus())
        {
            case DEBUG_STATUS_GO:
            case DEBUG_STATUS_GO_HANDLED:
            case DEBUG_STATUS_GO_NOT_HANDLED:
#ifndef FEATURE_PAL
                g_ExtControl->Execute(DEBUG_OUTCTL_NOT_LOGGED, "g", 0);
#else
                g_ExtControl->Execute(DEBUG_OUTCTL_NOT_LOGGED, "process continue", 0);
#endif
                break;
            default:
                break;
        }
    }

    return S_OK;
}
...
LLDBServices::SetExceptionCallback(
    PFN_EXCEPTION_CALLBACK callback)
{
    if (!g_exceptionbp.IsValid())
    {
        lldb::SBTarget target = m_debugger.GetSelectedTarget();
        if (!target.IsValid())
        {
            return E_FAIL;
        }
        lldb::SBBreakpoint exceptionbp = target.BreakpointCreateForException(lldb::LanguageType::eLanguageTypeC_plus_plus, false, true);
        if (!exceptionbp.IsValid())
        {
            return E_FAIL;
        }
#ifdef FLAGS_ANONYMOUS_ENUM
        exceptionbp.AddName("DoNotDeleteOrDisable");
#endif
        exceptionbp.SetCallback(ExceptionBreakpointCallback, (void *)callback);
        g_exceptionbp = exceptionbp;
    }
    return S_OK;
}

...
ExceptionBreakpointCallback(
    void *baton,
    lldb::SBProcess &process,
    lldb::SBThread &thread,
    lldb::SBBreakpointLocation &location)
{
    lldb::SBProcess* savedProcess = g_services->SetCurrentProcess(&process);
    lldb::SBThread* savedThread = g_services->SetCurrentThread(&thread);
    g_services->FlushCheck();

    bool result = ((PFN_EXCEPTION_CALLBACK)baton)(g_services) == S_OK;

    g_services->SetCurrentProcess(savedProcess);
    g_services->SetCurrentThread(savedThread);

    return result;
}
...

Root cause of the “LLDB works / GDB catch throw doesn’t” discrepancy:

Different kinds of “exceptions”
CoreCLR’s managed throw path on Linux (PAL) does NOT use a native C++ throw for each managed exception. It builds an EE exception record and unwinds via its own helpers (e.g. RaiseTheExceptionInternalOnly / IL_Throw), not a language-level throw that GDB’s catchpoint recognizes.

What LLDB’s breakpoint actually traps
LLDB’s BreakpointCreateForException(LanguageType::C_plus_plus, false, true) doesn’t just hook source “throw;” statements. Internally LLDB instruments the unwinder/runtime personality function and can report more low-level unwind starts (implementation detail). GDB’s “catch throw” is narrower: it stops only on actual C++ throw expressions generated by the compiler with exception tables. If CoreCLR uses hand-written unwinding or assembly helpers, LLDB may still surface them; GDB won’t.

Filtering in SOS LLDB path shows most hits are noise
The code you pasted:
if (!CheckCLRNotificationEvent(&dle)) { process continue; return S_OK; } (PAL)
This means the LLDB exception breakpoint is broad and fires frequently, but on Linux almost every stop is auto-continued because it’s NOT a CLR notification. Only true CLR notification “events” (translated by TranslateExceptionRecordToNotification) are consumed. Net effect: LLDB gets a stream of exception stops (“pulses”) it can mine; GDB currently receives none because its catchpoint doesn’t see those same low-level unwinds.

Timing difference
LLDB sets its exception breakpoint BEFORE running into coreclr code (right after plugin init). Your GDB test added “catch throw” only AFTER stopping at coreclr_execute_assembly—so any early one-shot notification-style throws during startup (if there are any recognizable) were already past. Even if some are thrown later, GDB’s narrower hook still misses them.

Windows vs FEATURE_PAL divergence
On Windows there is a distinct first‑chance CLRDBG_NOTIFICATION exception (RaiseException) that both debuggers can catch. On Linux (FEATURE_PAL), that mechanism becomes an internal CLR path without a user-mode OS exception. The LLDB plugin relies on its broader low-level unwind instrumentation to approximate notifications; GDB doesn’t approximate—so you get zero stops.

Why your extra breakpoint on RtlpRaiseException never hit
That symbol is Windows-specific. On Linux the path to an unhandled managed exception ends in calling raise(SIGABRT) (what you saw in the backtrace). So nothing to hit there.

What this means for us:

Relying on “catch throw” in GDB will never deliver the steady pulses LLDB gets.
The two callbacks you saw are exactly the only GDB stops we created (runtime entry + fatal SIGABRT).
To emulate LLDB’s notification stream we must synthesize pulses (polling or helper breakpoints) or hook a different runtime function (e.g. PreStubWorker, ThePreStub, or JIT manager helpers) to fire the exception callback and auto-continue.
If you want to validate this analysis before any changes: A. Start over but set:
(gdb) catch throw
(gdb) break coreclr_execute_assembly
(gdb) run
You’ll still almost certainly see zero intermediate throws—confirming timing isn’t the only factor. B. Probe for JIT helpers:
(gdb) info functions PreStubWorker
(gdb) info functions ThePreStub
If either resolves, set a silent breakpoint there and see if it triggers early JIT work. C. Enable extremely verbose LLDB session (if you compare) to count how many exception-breakpoint firings are auto-continued on Linux—likely >0 even for a trivial program.

Next diagnostic pivot (still no fixes):

Decide which runtime helper (or synthetic scheduler) gives a stable early pulse count (e.g. first 5–10 JIT helper hits).
Verify that calling the SOS exception callback during those pulses causes pending bpmd to bind (trace category “bpmd”).
Let me know when you’ve done A/B; I’ll map out the minimal helper-breakpoint vs synthetic pulse instrumentation paths, still behind an env guard.
