I’ll first analyze the LLDB flow vs. our GDB flow and pinpoint how that impacts the DAC hang, then propose an alignment plan without changing code yet.

Checklist:

Summarize LLDB plugin sequence for host runtime + DAC.
Contrast with our current GDB plugin sequence.
Explain how the divergence can cause PAL getenv hangs.
Propose concrete alignment steps and guardrails.
Analysis:

LLDB sequence (single runtime instance, native path):

The plugin initializes the host runtime first (coreclr and host-side runtime services are brought up).
SOS is initialized with that same host and target; when SOS needs IXCLRDataProcess it calls into the already-initialized IRuntime (native) to obtain it.
The native runtime code handles DAC path resolution and calls CLRDataCreateInstance in a context/pacing that’s known-good for PAL. LLDB’s DataTarget and services are wired natively and don’t cross a second “runtime instance.”
Our GDB sequence (two runtime instances, Python DAC path):

We initialize a full/native host runtime “somewhere else,” but the IRuntime we return to SOS is a separate, simplified Python implementation.
Our Python IRuntime then tries to load libmscordaccore and call CLRDataCreateInstance on its own, with a Python-implemented ICLRDataTarget2 and through GDB’s embedded Python.
This creates two independent runtime worlds: the native host runtime we stood up vs. the Python “IRuntime” we return to SOS. DAC creation happens from the Python side, not the native runtime that LLDB uses.
Result: CLRDataCreateInstance runs in the wrong context/timing and hits PAL’s getenv path during ClrDataAccess construction. Because the PAL/environment state is tied to the native runtime’s initialization order and critical sections, this can wedge in GetEnvironmentVariableA. Inline vs. threaded calls don’t change that fundamental mismatch.
Why LLDB doesn’t hang where we do:

A single, native IRuntime instance is used end-to-end.
DAC is created by that native runtime, after libcoreclr and related PAL state are ready, and using the native debugger services/datata rget integration.
No cross-instance PAL/environment contention and no Python/GDB re-entrancy when constructing ClrDataAccess.
Alignment plan:

Unify runtime source:

Stop returning the Python IRuntime from target_get_runtime; instead, return the native IRuntime pointer created by the host runtime you already initialize.
Ensure IHostServices::CreateTarget/UpdateTarget/GetCurrentTarget hand out the same native ITarget/IRuntime pair SOS expects.
Delegate DAC creation:

Remove our Python DAC loading logic and the Python ICLRDataTarget2 from the IRuntime path.
Let IRuntime::GetClrDataProcess call through to the native runtime implementation (which will load libmscordaccore and call CLRDataCreateInstance in the correct context).
Keep GDB services:

Continue to expose IDebuggerServices/ILLDBServices from Python so native SOS/runtime can call back for memory, modules, and thread context. If the native bridge already has a datatarget that wraps these services, use that; otherwise add a thin native adapter in the bridge to avoid Python implementing CLRDataTarget directly.
Safety switches and fallback:

Behind a feature flag, allow falling back to the old Python path for diagnostics only. Default to the native runtime path.
Keep the inline/timeout guards for now, but they shouldn’t trigger once the native runtime owns DAC creation.
Verification:

With unified runtime, re-test clrstack and bpmd binding.
Confirm JIT notifications flow and no “program already running” errors reappear.
If you’re aligned with this direction, I’ll update our host services to surface the native ITarget/IRuntime to SOS and remove the Python-side DAC path, keeping your existing native runtime initialization as the single source of truth.
